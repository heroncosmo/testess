#!/usr/bin/env python3
"""
PEACOCK COSM√âTICOS - CONFIGURA√á√ÉO DE CACHE EFICIENTE
Implementa pol√≠ticas de cache para economizar 67 KiB em recursos est√°ticos
"""

import os
import json
import re

def create_htaccess_cache_rules():
    """Cria regras de cache no .htaccess"""
    print("üìÅ Criando regras de cache .htaccess...")
    
    htaccess_content = """# PEACOCK COSM√âTICOS - CACHE OPTIMIZATION
# Generated by performance optimization script

# Enable compression
<IfModule mod_deflate.c>
    AddOutputFilterByType DEFLATE text/plain
    AddOutputFilterByType DEFLATE text/html
    AddOutputFilterByType DEFLATE text/xml
    AddOutputFilterByType DEFLATE text/css
    AddOutputFilterByType DEFLATE application/xml
    AddOutputFilterByType DEFLATE application/xhtml+xml
    AddOutputFilterByType DEFLATE application/rss+xml
    AddOutputFilterByType DEFLATE application/javascript
    AddOutputFilterByType DEFLATE application/x-javascript
    AddOutputFilterByType DEFLATE application/json
    AddOutputFilterByType DEFLATE image/svg+xml
</IfModule>

# Browser Caching
<IfModule mod_expires.c>
    ExpiresActive On
    
    # Images
    ExpiresByType image/jpg "access plus 1 year"
    ExpiresByType image/jpeg "access plus 1 year"
    ExpiresByType image/gif "access plus 1 year"
    ExpiresByType image/png "access plus 1 year"
    ExpiresByType image/webp "access plus 1 year"
    ExpiresByType image/svg+xml "access plus 1 year"
    
    # CSS and JavaScript
    ExpiresByType text/css "access plus 1 month"
    ExpiresByType application/javascript "access plus 1 month"
    ExpiresByType application/x-javascript "access plus 1 month"
    ExpiresByType text/javascript "access plus 1 month"
    
    # Fonts
    ExpiresByType font/woff "access plus 1 year"
    ExpiresByType font/woff2 "access plus 1 year"
    ExpiresByType application/font-woff "access plus 1 year"
    ExpiresByType application/font-woff2 "access plus 1 year"
    
    # Videos
    ExpiresByType video/mp4 "access plus 1 month"
    ExpiresByType video/webm "access plus 1 month"
    
    # HTML
    ExpiresByType text/html "access plus 1 hour"
</IfModule>

# Cache-Control Headers
<IfModule mod_headers.c>
    # CSS and JS files
    <FilesMatch "\\.(css|js)$">
        Header set Cache-Control "public, max-age=2592000"
    </FilesMatch>
    
    # Image files
    <FilesMatch "\\.(jpg|jpeg|png|gif|webp|svg)$">
        Header set Cache-Control "public, max-age=31536000"
    </FilesMatch>
    
    # Font files
    <FilesMatch "\\.(woff|woff2|ttf|eot)$">
        Header set Cache-Control "public, max-age=31536000"
    </FilesMatch>
    
    # Video files
    <FilesMatch "\\.(mp4|webm|ogg)$">
        Header set Cache-Control "public, max-age=2592000"
    </FilesMatch>
    
    # HTML files
    <FilesMatch "\\.html$">
        Header set Cache-Control "public, max-age=3600"
    </FilesMatch>
</IfModule>

# ETags
<IfModule mod_headers.c>
    Header unset ETag
</IfModule>
FileETag None

# Security headers
<IfModule mod_headers.c>
    Header always set X-Content-Type-Options nosniff
    Header always set X-Frame-Options DENY
    Header always set X-XSS-Protection "1; mode=block"
    Header always set Referrer-Policy "strict-origin-when-cross-origin"
</IfModule>
"""
    
    with open('.htaccess', 'w', encoding='utf-8') as f:
        f.write(htaccess_content)
    
    print("   ‚úÖ Arquivo .htaccess criado com regras de cache")

def add_cache_meta_tags():
    """Adiciona meta tags para controle de cache"""
    print("üè∑Ô∏è Adicionando meta tags de cache...")
    
    with open('index.html', 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Meta tags para cache
    cache_meta = '''
<!-- Cache Control Meta Tags -->
<meta http-equiv="Cache-Control" content="public, max-age=3600">
<meta http-equiv="Pragma" content="cache">
<meta name="cache-optimization" content="enabled">
'''
    
    # Inserir ap√≥s as meta tags existentes
    content = re.sub(
        r'(<!-- Image Optimization Meta Tags -->)',
        cache_meta + r'\1',
        content
    )
    
    with open('index.html', 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("   ‚úÖ Meta tags de cache adicionadas")

def add_service_worker():
    """Adiciona Service Worker para cache avan√ßado"""
    print("‚öôÔ∏è Criando Service Worker...")
    
    service_worker_content = """// PEACOCK COSM√âTICOS - SERVICE WORKER
// Cache optimization for static resources

const CACHE_NAME = 'peacock-cosmeticos-v1';
const STATIC_CACHE_URLS = [
    './',
    './wp-content/plugins/elementor/assets/css/frontend.min.css',
    './wp-content/uploads/elementor/css/post-16.css',
    './wp-content/uploads/2024/10/banner01.jpg',
    './wp-content/uploads/2024/10/banner03.jpg',
    './wp-content/uploads/2024/10/peecock-08.png',
    './wp-content/uploads/2024/10/selo-aprovado-anvisa-p_optimized.webp',
    './wp-includes/js/jquery/jquery.min.js'
];

// Install event
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                console.log('Caching static resources');
                return cache.addAll(STATIC_CACHE_URLS);
            })
    );
});

// Fetch event
self.addEventListener('fetch', event => {
    // Only cache GET requests
    if (event.request.method !== 'GET') return;
    
    // Skip non-HTTP requests
    if (!event.request.url.startsWith('http')) return;
    
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // Return cached version if available
                if (response) {
                    return response;
                }
                
                // Fetch from network
                return fetch(event.request)
                    .then(response => {
                        // Don't cache non-successful responses
                        if (!response || response.status !== 200 || response.type !== 'basic') {
                            return response;
                        }
                        
                        // Clone the response
                        const responseToCache = response.clone();
                        
                        // Cache static resources
                        if (shouldCache(event.request.url)) {
                            caches.open(CACHE_NAME)
                                .then(cache => {
                                    cache.put(event.request, responseToCache);
                                });
                        }
                        
                        return response;
                    });
            })
    );
});

// Activate event
self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (cacheName !== CACHE_NAME) {
                        console.log('Deleting old cache:', cacheName);
                        return caches.delete(cacheName);
                    }
                })
            );
        })
    );
});

// Helper function to determine if URL should be cached
function shouldCache(url) {
    const cacheableExtensions = ['.css', '.js', '.jpg', '.jpeg', '.png', '.webp', '.svg', '.woff', '.woff2'];
    return cacheableExtensions.some(ext => url.includes(ext));
}
"""
    
    with open('sw.js', 'w', encoding='utf-8') as f:
        f.write(service_worker_content)
    
    print("   ‚úÖ Service Worker criado")

def register_service_worker():
    """Registra o Service Worker no HTML"""
    print("üìù Registrando Service Worker...")
    
    with open('index.html', 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Script para registrar Service Worker
    sw_registration = """
<script>
// Service Worker Registration
if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
        navigator.serviceWorker.register('./sw.js')
            .then(function(registration) {
                console.log('ServiceWorker registration successful');
            })
            .catch(function(err) {
                console.log('ServiceWorker registration failed: ', err);
            });
    });
}
</script>
"""
    
    # Adicionar antes do fechamento do body
    content = re.sub(r'</body>', sw_registration + '</body>', content)
    
    with open('index.html', 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("   ‚úÖ Service Worker registrado")

def add_preload_hints():
    """Adiciona hints de preload para recursos cr√≠ticos"""
    print("üöÄ Adicionando hints de preload...")
    
    with open('index.html', 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Verificar se j√° existem preload hints
    if 'rel="preload"' in content:
        print("   ‚ÑπÔ∏è Preload hints j√° existem")
        return
    
    # Hints de preload para recursos cr√≠ticos
    preload_hints = '''
<!-- Critical Resource Preload Hints -->
<link rel="preload" href="./wp-content/plugins/elementor/assets/css/frontend.min.css" as="style">
<link rel="preload" href="./wp-content/uploads/elementor/css/post-16.css" as="style">
<link rel="preload" href="./wp-includes/js/jquery/jquery.min.js" as="script">
<link rel="prefetch" href="./wp-content/uploads/2024/10/banner03.jpg">
'''
    
    # Inserir ap√≥s as meta tags
    content = re.sub(
        r'(<meta name="viewport"[^>]*>)',
        r'\1' + preload_hints,
        content
    )
    
    with open('index.html', 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("   ‚úÖ Hints de preload adicionados")

def create_cache_manifest():
    """Cria manifest para cache de aplica√ß√£o"""
    print("üìã Criando cache manifest...")
    
    manifest_content = """CACHE MANIFEST
# Version 1.0 - Peacock Cosm√©ticos

CACHE:
./
./wp-content/plugins/elementor/assets/css/frontend.min.css
./wp-content/uploads/elementor/css/post-16.css
./wp-content/uploads/2024/10/banner01.jpg
./wp-content/uploads/2024/10/banner03.jpg
./wp-content/uploads/2024/10/peecock-08.png
./wp-content/uploads/2024/10/selo-aprovado-anvisa-p_optimized.webp
./wp-includes/js/jquery/jquery.min.js

NETWORK:
*

FALLBACK:
/ ./offline.html
"""
    
    with open('cache.manifest', 'w', encoding='utf-8') as f:
        f.write(manifest_content)
    
    print("   ‚úÖ Cache manifest criado")

def create_caching_report():
    """Cria relat√≥rio das configura√ß√µes de cache"""
    print("üìä Gerando relat√≥rio de cache...")
    
    # Verificar arquivos criados
    files_created = []
    if os.path.exists('.htaccess'):
        files_created.append('.htaccess')
    if os.path.exists('sw.js'):
        files_created.append('sw.js')
    if os.path.exists('cache.manifest'):
        files_created.append('cache.manifest')
    
    # Analisar HTML para verificar otimiza√ß√µes
    with open('index.html', 'r', encoding='utf-8') as f:
        content = f.read()
    
    preload_count = len(re.findall(r'rel="preload"', content))
    prefetch_count = len(re.findall(r'rel="prefetch"', content))
    cache_meta_count = len(re.findall(r'Cache-Control', content))
    
    report = {
        "cache_optimization_summary": {
            "files_created": files_created,
            "preload_hints": preload_count,
            "prefetch_hints": prefetch_count,
            "cache_meta_tags": cache_meta_count,
            "service_worker_enabled": os.path.exists('sw.js'),
            "htaccess_rules": os.path.exists('.htaccess'),
            "estimated_savings_kb": 67,
            "optimizations_applied": [
                "Browser caching with .htaccess",
                "Service Worker for offline caching",
                "Resource preload hints",
                "Cache-Control meta tags",
                "Compression enabled",
                "Cache manifest created"
            ]
        }
    }
    
    # Salvar relat√≥rio
    with open('cache_optimization_report.json', 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    return report

def main():
    """Executa todas as configura√ß√µes de cache"""
    print("üéØ CONFIGURANDO CACHE EFICIENTE - PEACOCK COSM√âTICOS\n")
    
    # Backup do arquivo original
    if not os.path.exists('index_cache_backup.html'):
        with open('index.html', 'r', encoding='utf-8') as f:
            content = f.read()
        with open('index_cache_backup.html', 'w', encoding='utf-8') as f:
            f.write(content)
        print("üìã Backup criado: index_cache_backup.html")
    
    # Executar configura√ß√µes
    create_htaccess_cache_rules()
    add_cache_meta_tags()
    add_service_worker()
    register_service_worker()
    add_preload_hints()
    create_cache_manifest()
    report = create_caching_report()
    
    print("\nüéâ CACHE CONFIGURADO!")
    print("üìä Resultados:")
    print(f"   üìÅ Arquivos criados: {', '.join(report['cache_optimization_summary']['files_created'])}")
    print(f"   üöÄ Hints de preload: {report['cache_optimization_summary']['preload_hints']}")
    print(f"   ‚öôÔ∏è Service Worker: {'‚úÖ' if report['cache_optimization_summary']['service_worker_enabled'] else '‚ùå'}")
    print(f"   üìã Regras .htaccess: {'‚úÖ' if report['cache_optimization_summary']['htaccess_rules'] else '‚ùå'}")
    print(f"   üíæ Economia estimada: {report['cache_optimization_summary']['estimated_savings_kb']} KiB")

if __name__ == "__main__":
    main()
